# 设计决策文档 (Design Decisions)

## 1. 为什么将默认账本存储在用户信息中？

### 选择的方案
在 `UserEntity` 中添加 `defaultLedgerId` 字段。

### 其他考虑的方案
1. ❌ **独立的用户偏好表**
   - 优点：更灵活，可以扩展更多偏好设置
   - 缺点：增加查询复杂度，对于单一字段过度设计

2. ❌ **存储在客户端本地**
   - 优点：减少服务器压力
   - 缺点：无法跨设备同步，不符合用户预期

3. ✅ **直接存储在用户表**
   - 优点：查询简单，性能好，易于维护
   - 缺点：用户表字段增多（可接受）

### 决策理由
- 默认账本是用户级别的配置，逻辑上属于用户信息
- 查询频率高，与用户信息一起加载性能最优
- 实现简单，维护成本低
- 符合"简单即美"的原则

---

## 2. 为什么同时维护 currentLedger 和 defaultLedgerId？

### 设计思路
```
defaultLedgerId (持久化)  →  初始化时  →  currentLedger (会话状态)
                              ↓
                        用户可以临时切换
                              ↓
                        不影响 defaultLedgerId
```

### 决策理由
- **defaultLedgerId**: 用户的长期偏好，持久化存储
- **currentLedger**: 当前会话的临时状态，可以随时切换
- 这样既保证了用户偏好的持久性，又提供了灵活的临时切换能力

### 使用场景
- 用户设置"家庭账本"为默认
- 临时查看"公司账本"的交易（切换 currentLedger）
- 下次打开应用，仍然默认选择"家庭账本"（使用 defaultLedgerId）

---

## 3. 为什么选择并行加载而不是串行加载？

### 实现代码
```typescript
const [ledgersData, defaultId] = await Promise.all([
    ledgerAPI.getAll(),
    userAPI.getDefaultLedger(),
]);
```

### 决策理由
- **性能优化**: 两个独立的 API 调用可以并行执行
- **用户体验**: 减少等待时间，更快显示界面
- **容错性**: 即使获取默认ID失败，账本列表仍可正常显示

### 性能对比
- 串行加载: T1 + T2 ≈ 300ms + 100ms = 400ms
- 并行加载: max(T1, T2) ≈ max(300ms, 100ms) = 300ms
- **提升约 25%**

---

## 4. UI设计：为什么选择 Telegram + Google 混合风格？

### Telegram 风格元素
1. **左侧强调条** (4px 蓝色)
   - 用途：标识当前选中的账本
   - 特点：微妙但清晰，不喧宾夺主

2. **简洁的徽章设计**
   - 用途：标识默认账本
   - 特点：小巧、信息密度高

3. **扁平化图标**
   - 用途：账本类型识别
   - 特点：使用emoji，简洁直观

### Google Material Design 元素
1. **圆润的卡片**
   - 大圆角 (BorderRadius.xl)
   - 柔和的阴影 (Shadows.md)

2. **FAB 按钮**
   - 悬浮在右下角
   - 明显的阴影和点击反馈

3. **底部按钮栏**
   - 固定在底部
   - 高度适中，易于点击
   - 明确的视觉层级

### 决策理由
- **Telegram**: 信息密度高，适合列表展示
- **Google**: 交互友好，符合用户习惯
- **混合**: 取长补短，既简洁又易用

---

## 5. 为什么使用"设为默认"而不是"切换到此账本"？

### 语义分析

| 旧文案 | 新文案 | 区别 |
|--------|--------|------|
| 切换到此账本 | 设为默认账本 | 临时 vs 永久 |

### 决策理由
1. **明确性**: "设为默认"清楚表明是设置长期偏好
2. **持久性**: 用户理解这是一个会被记住的操作
3. **区分度**: 与"查看详情"（临时操作）区分开

### 用户心智模型
```
设为默认 → 我希望以后都默认使用这个账本
切换到  → 我只是现在想看看这个账本
```

---

## 6. 为什么默认徽章使用黄色星标？

### 色彩心理学
- **黄色**: 醒目、积极、重要
- **星标⭐**: 收藏、默认、首选的通用符号

### 设计对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| 蓝色勾选 | 符合主题色 | 与选中状态混淆 |
| 绿色对勾 | 表示完成 | 语义不准确 |
| ✅ **黄色星标** | **醒目且语义清晰** | **无明显缺点** |

### 参考案例
- Gmail: 星标邮件
- iOS: 收藏联系人
- 微信: 星标朋友

---

## 7. 数据一致性保证

### 场景：删除账本时的处理

```typescript
// 删除账本后的处理逻辑
if (currentLedger?.id === id) {
    const remaining = ledgers.filter(l => l.id !== id);
    // 优先选择默认账本，其次选择第一个
    const defaultLedger = defaultLedgerId 
        ? remaining.find(l => l.id === defaultLedgerId) 
        : null;
    setCurrentLedgerState(defaultLedger || remaining[0] || null);
}
```

### 决策理由
- **智能降级**: 按优先级选择替代账本
- **避免空状态**: 尽可能保持有效的当前账本
- **用户体验**: 减少用户困惑和额外操作

---

## 8. 为什么不自动清除被删除账本的默认设置？

### 当前实现
- 数据库外键: `ON DELETE SET NULL`
- 前端逻辑: 如果默认账本不存在，自动选择第一个

### 决策理由
1. **数据完整性**: 由数据库保证
2. **简化逻辑**: 前端不需要主动清除
3. **性能考虑**: 减少不必要的API调用

### 备选方案
- ❌ 前端主动清除: 需要额外的API调用，增加复杂度
- ❌ 阻止删除默认账本: 用户体验差，限制过多

---

## 9. 扩展性设计

### 预留的扩展点

1. **多设备同步**
   - 默认账本存储在服务器
   - 天然支持多设备同步

2. **个性化推荐**
   - 可以基于 defaultLedgerId 分析用户习惯
   - 推荐相关的分类和标签

3. **上下文感知**
   ```typescript
   // 未来可以扩展为
   interface UserPreferences {
       defaultLedgerId: number;
       workLedgerId?: number;    // 工作时间的默认账本
       homeLedgerId?: number;    // 家庭时间的默认账本
       locationBasedLedgers?: Map<Location, number>;
   }
   ```

4. **分类默认账本**
   - 餐饮类交易 → 家庭账本
   - 办公用品 → 公司账本

---

## 10. 测试策略

### 单元测试覆盖
```typescript
describe('LedgerContext', () => {
    test('应该在初始化时选择默认账本', async () => {
        // 测试 loadInitialData 逻辑
    });
    
    test('应该在设置默认账本后更新状态', async () => {
        // 测试 setDefaultLedger 逻辑
    });
    
    test('应该在默认账本不存在时降级到第一个', async () => {
        // 测试降级逻辑
    });
});
```

### 集成测试场景
1. 用户首次登录 → 无默认账本 → 自动选择第一个
2. 用户设置默认账本 → 重启应用 → 自动选择默认账本
3. 用户删除默认账本 → 自动选择其他账本

### E2E测试流程
```
登录 → 创建账本 → 设为默认 → 
新增交易 → 验证使用默认账本 → 
删除默认账本 → 验证自动切换
```

---

## 总结

所有设计决策都遵循以下原则：
1. **简单性**: 优先选择最简单的实现方案
2. **性能**: 在不牺牲可维护性的前提下优化性能
3. **用户体验**: 以用户的直觉和习惯为中心
4. **扩展性**: 为未来的功能扩展预留空间
5. **一致性**: 保持与现有代码和设计的一致性

这些决策确保了功能的完善性和系统的长期可维护性。
